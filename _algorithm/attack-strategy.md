---
layout: default
title: Problem Solving Strategies
---

{% include katex.html %}

哪些问题能够用greedy解决，能用greedy解决的原因是什么？实际上这是一个证明的问题。看过<https://www.youtube.com/watch?v=Oq1seKJvfQU>之后，再加上最近看了一些数学的东西，感觉是时候要总结一下了。不只是局限于对greedy的总计，而是总结如何解题，从一般性的角度出发。

# Solution Space

一个程序（一个具体的题）能给出正确的输出，就完成了任务。虽然大多数时候，我们无法像计算1+1=2那样直接得出最终结果，但我们知道这个目标输出是在一个范围之内/符合一定模式。

这个范围/模式/空间可以从各种角度去考虑。
* 从包含最终解的所有排列组合；
* 从输入参数的范围得到输出的所有可能。

想出来一个解空间之后，它能够帮助我们：
* 不同的解空间，也对应着不同的思路；
* 如果用brute force，它的复杂度是多少？这样就得知了解决这个问题的复杂度上限；
* 对一个解空间进行分析，想办法把最终目标从这个空间中找出来。

空间变换。把解空间变换一下，可能会降低复杂度，或降低维度。
* Convex Hull Optimization. 把原来解空间中的解视为一个点，在一条直线上的所有点就可以作为一条线段来处理。于是把点空间转换为线段空间。对于Convex Hull Optimization来说，在两条线段的交点之前$A>B$，交点之后$A<B$, 这样的话，线段的一半（对应于点空间中的很多点）就能够被整体剔除了。
* 圆和直线间的变换。In geometry, inversive geometry is the study of inversion, a transformation of the Euclidean plane that maps circles or lines to other circles or lines and that preserves the angles between crossing curves. Many difficult problems in geometry become much more tractable when an inversion is applied. <https://en.wikipedia.org/wiki/Inversive_geometry>


# Break Down

从一个解空间中，寻找最终目标，这一步才是解题的关键。所以需要对解空间进行分析。
* 从空间整体上对它进行分解。对空间分层；树结构；
   * 比如对于空间中的解是一个序列的情况，把包含相同元素但不同排列的解都放到同一层；然后在每一个层中，再考虑元素的排列。
* 解空间可以由子问题/子结构的解空间组成。动态规划；贪心；
* 分解之后的子空间，尽量避免互相交叠，尽量避免重复计算。动态规划；
* 最优化思路。在解空间中，从一个普通解出发，不断优化得到最优解。很显然，类似于梯度下降，不是所有空间都能得到全局最优解。
* 找到正确的切割方式切割空间，优化掉某些值。一定有某些值是优于其它值的，找到它们就相当于正确分解了解空间。找到朝向最优解的切入点。比如，极端情况下，时域转成频域处理。

除了检查解空间中每一个值（包括动态规划）这种方法，其它情况下，都需要证明我们的输出确实是最终目标。
* 数学归纳法。$A(0) = C, A(n) > A(n-1)$;
* 最优解 >= 贪心解 + 贪心解 >= 最优解 -> 贪心解 == 最优解；
* 反证法。最优解的性质有哪些。假设我们的输出不是最优解，想办法得到矛盾。最优解的性质一般比较明确，从它出发进行推导比较容易。
   * 比如要找最大值。先假设 贪心解 < 最大值，然后尝试从最大值经过修改得到贪心值（假设我们总是可以进行这样的修改），但是由于最大值/贪心值的性质，会发现有矛盾/行不通。得到 贪心解 >= 最大值。

正如数学上对于一个空间/目标有无数种分解形式一样，具体的解空间也有无数种分解法。如何分解它利于找到最终解，实际上需要对目标解空间有一定的了解才能做到。
* 从简单的形式出发，在草稿纸上画一画，看得到的解在解空间中有什么性质。N=1，N=2；
* 多个限定的情况下，先限定一定的条件，在简单情况下分析问题；也就是说，尝试分解限定条件。
* 比较空间中的两个元素。比如最优解和贪心解的比较。分析两个元素之间如何转化，得到最优解或最优解的性质。
* 从两个方向思考：由子空间如何扩展成大空间；大空间如何分解成小空间；
* 思考的过程和程序的实现经常是相反顺序的；
   * 比如动态规划，思考的方向是大空间如何从小空间得到；程序实现的时候，先从小空间开始逐步扩大。
   * 比如思考的时候可能是，先按照组合对解空间分层，然后再每个层内考虑不同排列；程序实现的时候，可能就是先按照最优排列整个排个序，然后在其基础上考虑不同组合。
* 对数据预处理后再分析；
   * 尤其是对于多次查询的问题，一次预处理，利于全部查询。
   * 对输入数据排序；
   * 对图结构转换成数结构；
      * DAG -> Dominator Tree
   * 对树结构建立binary lifting table。


# Complexity

$O(n)$         1M - 1G\
$O(n\log{n})$  200K - 100M\
$O(n^2)$       1K - 30K\
$O(n^3)$       100 - 1K\
$O(n^4)$       30 - 200\
$O(n^5)$       20 - 70\
$O(n!)$        10 - 13\



